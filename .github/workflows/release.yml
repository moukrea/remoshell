name: Release

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]
    branches: [main]

permissions:
  contents: write
  pages: write
  id-token: write

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # ========== RELEASE GATE ==========
  gate:
    name: Release Gate
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      head_sha: ${{ github.event.workflow_run.head_sha }}
    steps:
      - name: Check CI result and event type
        id: check
        run: |
          echo "CI workflow conclusion: ${{ github.event.workflow_run.conclusion }}"
          echo "CI workflow event: ${{ github.event.workflow_run.event }}"

          # Only release if CI passed AND it was a push (not PR)
          if [[ "${{ github.event.workflow_run.conclusion }}" == "success" && \
                "${{ github.event.workflow_run.event }}" == "push" ]]; then
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "Release gate: PASSED"
          else
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "Release gate: BLOCKED (CI: ${{ github.event.workflow_run.conclusion }}, Event: ${{ github.event.workflow_run.event }})"
          fi

  # ========== VERSION & CHANGELOG ==========
  prepare:
    needs: gate
    if: ${{ needs.gate.outputs.should_release == 'true' }}
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.new_version }}
      changelog: ${{ steps.changelog.outputs.content }}
      prev_tag: ${{ steps.version.outputs.prev_tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.gate.outputs.head_sha }}
          fetch-depth: 0

      - name: Get latest tag and bump version
        id: version
        run: |
          # Get latest tag or default to 0.0.0
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "prev_tag=$LATEST_TAG" >> $GITHUB_OUTPUT

          # Extract version numbers
          VERSION=${LATEST_TAG#v}
          MAJOR=$(echo $VERSION | cut -d. -f1)
          MINOR=$(echo $VERSION | cut -d. -f2)
          PATCH=$(echo $VERSION | cut -d. -f3)

          # Check commit messages for version bump type
          COMMITS=$(git log $LATEST_TAG..HEAD --pretty=format:"%s" 2>/dev/null || git log --pretty=format:"%s")

          if echo "$COMMITS" | grep -qE "^feat!:|^fix!:|BREAKING CHANGE"; then
            # Breaking change = major bump
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif echo "$COMMITS" | grep -qE "^feat"; then
            # Feature = minor bump
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            # Default = patch bump
            PATCH=$((PATCH + 1))
          fi

          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Bumping version: $VERSION -> $NEW_VERSION"

      - name: Update version numbers
        run: |
          VERSION="${{ steps.version.outputs.new_version }}"
          echo "Updating all components to version: $VERSION"

          # Run version bump script
          chmod +x ./scripts/bump-version.sh
          ./scripts/bump-version.sh "$VERSION"

          echo "Version update complete"

      - name: Commit version changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check if there are changes to commit
          if git diff --quiet; then
            echo "No version changes needed - versions already correct"
          else
            git add -A
            git commit -m "chore: bump version to ${{ steps.version.outputs.new_version }}"
            git push origin HEAD:main
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Install git-cliff
        run: |
          GC_URL=$(curl -s https://api.github.com/repos/orhun/git-cliff/releases/latest \
            | jq -r '.assets[] | select(.name | test("x86_64-unknown-linux-gnu.tar.gz$")) | .browser_download_url')
          curl -sSfL "$GC_URL" | tar xz --strip-components=1 -C /usr/local/bin
          git-cliff --version

      - name: Generate changelog
        id: changelog
        run: |
          # Function to generate fallback changelog using git log
          generate_fallback_changelog() {
            local prev_tag=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
            if [ -n "$prev_tag" ]; then
              echo "## What's Changed"
              echo ""
              git log --pretty=format:"- %s (%h)" ${prev_tag}..HEAD | head -100
            else
              echo "## Initial Release"
              echo ""
              git log --pretty=format:"- %s (%h)" | head -50
            fi
          }

          USE_FALLBACK=false

          # Try git-cliff first
          if command -v git-cliff &> /dev/null && [ -f cliff.toml ]; then
            echo "Generating changelog with git-cliff..."
            if git cliff --unreleased --strip header > CHANGES.md 2>/dev/null && [ -s CHANGES.md ]; then
              echo "Generated changelog with git-cliff"
            else
              echo "::warning::git-cliff failed or produced empty output, falling back to git log"
              USE_FALLBACK=true
            fi
          else
            echo "::warning::git-cliff not available or cliff.toml missing, using git log fallback"
            USE_FALLBACK=true
          fi

          # Fallback to git log if needed
          if [ "$USE_FALLBACK" = "true" ]; then
            generate_fallback_changelog > CHANGES.md
          fi

          # Validate changelog is not empty
          if [ ! -s CHANGES.md ]; then
            echo "::warning::Changelog is empty after generation, creating minimal changelog"
            echo "## Release" > CHANGES.md
            echo "" >> CHANGES.md
            echo "No changes documented for this release." >> CHANGES.md
          fi

          echo "=== Generated Changelog ==="
          cat CHANGES.md

          # Output changelog content using heredoc
          {
            echo "content<<CHANGELOG_EOF"
            cat CHANGES.md
            echo ""
            echo "CHANGELOG_EOF"
          } >> $GITHUB_OUTPUT

  # ========== DAEMON BUILD (Linux only for now) ==========
  build-daemon:
    needs: [gate, prepare]
    if: ${{ needs.gate.outputs.should_release == 'true' }}
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.gate.outputs.head_sha }}
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev
      - uses: dtolnay/rust-toolchain@stable
      - uses: Swatinem/rust-cache@v2
      - run: cargo build --release -p daemon
      - name: Rename binary
        run: |
          mkdir -p dist
          cp target/release/remoshell-daemon dist/remoshell-daemon-linux-x86_64
      - uses: actions/upload-artifact@v4
        with:
          name: daemon-linux-x86_64
          path: dist/remoshell-daemon-linux-x86_64

  # ========== DESKTOP BUILD (Linux only for now) ==========
  build-desktop:
    needs: [gate, prepare]
    if: ${{ needs.gate.outputs.should_release == 'true' }}
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.gate.outputs.head_sha }}
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: client/package-lock.json
      - uses: dtolnay/rust-toolchain@stable
      - uses: Swatinem/rust-cache@v2
        with:
          workspaces: client/src-tauri -> target

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Install frontend dependencies
        working-directory: client
        run: npm ci

      - name: Build Tauri app
        uses: tauri-apps/tauri-action@v0
        with:
          projectPath: client
          tauriScript: npm run tauri

      - uses: actions/upload-artifact@v4
        with:
          name: desktop-linux-x86_64
          path: |
            client/src-tauri/target/release/bundle/deb/*.deb
            client/src-tauri/target/release/bundle/appimage/*.AppImage
          if-no-files-found: error

  # ========== ANDROID BUILD ==========
  build-android:
    needs: [gate, prepare]
    if: ${{ needs.gate.outputs.should_release == 'true' }}
    runs-on: ubuntu-latest
    env:
      # Evaluate secret availability at job level for use in step conditions
      HAS_SIGNING_KEY: ${{ secrets.ANDROID_SIGNING_KEY != '' }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.gate.outputs.head_sha }}
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: client/package-lock.json
      - uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
      - uses: android-actions/setup-android@v3
      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-linux-android,armv7-linux-androideabi,i686-linux-android,x86_64-linux-android
      - uses: Swatinem/rust-cache@v2

      - name: Install NDK
        run: sdkmanager "ndk;26.1.10909125"

      - name: Install frontend dependencies
        working-directory: client
        run: npm ci

      - name: Initialize Android project
        working-directory: client
        run: npm run tauri android init

      - name: Copy custom Android icons
        working-directory: client
        run: |
          # Copy custom RemoShell icons to replace default Tauri icons
          # Source: src-tauri/icons/android/ -> gen/android/app/src/main/res/
          echo "Copying custom Android icons..."

          RES_DIR="src-tauri/gen/android/app/src/main/res"

          # Copy all mipmap directories (icons for different densities)
          for density in mdpi hdpi xhdpi xxhdpi xxxhdpi; do
            if [ -d "src-tauri/icons/android/mipmap-$density" ]; then
              mkdir -p "$RES_DIR/mipmap-$density"
              cp -r "src-tauri/icons/android/mipmap-$density"/* "$RES_DIR/mipmap-$density/"
              echo "  Copied mipmap-$density"
            fi
          done

          # Copy adaptive icon XML (Android 8.0+)
          if [ -d "src-tauri/icons/android/mipmap-anydpi-v26" ]; then
            mkdir -p "$RES_DIR/mipmap-anydpi-v26"
            cp -r "src-tauri/icons/android/mipmap-anydpi-v26"/* "$RES_DIR/mipmap-anydpi-v26/"
            echo "  Copied mipmap-anydpi-v26"
          fi

          # Copy values directory (background color for adaptive icon)
          if [ -d "src-tauri/icons/android/values" ]; then
            mkdir -p "$RES_DIR/values"
            cp "src-tauri/icons/android/values"/* "$RES_DIR/values/"
            echo "  Copied values (icon background)"
          fi

          echo "Android icon copy complete"

      - name: Build Android APK
        working-directory: client
        run: npm run tauri android build
        env:
          NDK_HOME: ${{ env.ANDROID_SDK_ROOT }}/ndk/26.1.10909125

      - name: Sign APK
        if: ${{ env.HAS_SIGNING_KEY == 'true' }}
        env:
          ANDROID_SIGNING_KEY: ${{ secrets.ANDROID_SIGNING_KEY }}
          ANDROID_KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
          ANDROID_KEYSTORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
          ANDROID_KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}
        run: |
          APK_DIR="client/src-tauri/gen/android/app/build/outputs/apk/universal/release"
          UNSIGNED_APK="$APK_DIR/app-universal-release-unsigned.apk"
          SIGNED_APK="$APK_DIR/app-universal-release-signed.apk"

          # Decode keystore from base64
          echo "$ANDROID_SIGNING_KEY" | base64 -d > /tmp/keystore.jks

          # Find apksigner
          BUILD_TOOLS_DIR=$(ls -d $ANDROID_SDK_ROOT/build-tools/*/ | sort -V | tail -1)
          APKSIGNER="${BUILD_TOOLS_DIR}apksigner"

          echo "Using apksigner: $APKSIGNER"
          echo "Signing: $UNSIGNED_APK"

          "$APKSIGNER" sign \
            --ks /tmp/keystore.jks \
            --ks-key-alias "$ANDROID_KEY_ALIAS" \
            --ks-pass "pass:$ANDROID_KEYSTORE_PASSWORD" \
            --key-pass "pass:$ANDROID_KEY_PASSWORD" \
            --out "$SIGNED_APK" \
            "$UNSIGNED_APK"

          # Cleanup
          rm -f /tmp/keystore.jks

          echo "APK signed successfully"
          ls -la "$APK_DIR"

      - name: Rename APK for release
        run: |
          mkdir -p client/dist-android
          # Find the universal APK (signed if available, unsigned otherwise)
          APK_DIR="client/src-tauri/gen/android/app/build/outputs/apk/universal/release"

          echo "Looking for APK in: $APK_DIR"
          ls -la "$APK_DIR" || echo "Directory listing failed"

          if [ -f "$APK_DIR/app-universal-release-signed.apk" ]; then
            cp "$APK_DIR/app-universal-release-signed.apk" "client/dist-android/remoshell-client-android.apk"
            echo "Copied signed APK"
          elif [ -f "$APK_DIR/app-universal-release-unsigned.apk" ]; then
            cp "$APK_DIR/app-universal-release-unsigned.apk" "client/dist-android/remoshell-client-android.apk"
            echo "Copied unsigned APK"
          else
            # Fallback: find any APK
            APK_FILE=$(find "$APK_DIR" -name "*.apk" -type f | head -1)
            if [ -n "$APK_FILE" ]; then
              cp "$APK_FILE" "client/dist-android/remoshell-client-android.apk"
              echo "Copied fallback APK: $APK_FILE"
            else
              echo "ERROR: No APK file found in $APK_DIR"
              exit 1
            fi
          fi

          # Verify the APK was copied successfully
          if [ ! -f "client/dist-android/remoshell-client-android.apk" ]; then
            echo "ERROR: APK was not copied to destination"
            exit 1
          fi

          echo "APK renamed to remoshell-client-android.apk"
          ls -la client/dist-android/

      - uses: actions/upload-artifact@v4
        with:
          name: android-apk
          path: client/dist-android/remoshell-client-android.apk
          if-no-files-found: error

  # ========== WEB BUILD ==========
  build-web:
    needs: [gate, prepare]
    if: ${{ needs.gate.outputs.should_release == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.gate.outputs.head_sha }}
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: client/package-lock.json

      - name: Install dependencies
        working-directory: client
        run: npm ci

      - name: Build web
        working-directory: client
        run: npm run build
        env:
          BASE_URL: /remoshell/

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: client/dist

  # ========== DEPLOY GITHUB PAGES ==========
  deploy-pages:
    needs: [gate, build-web]
    if: ${{ needs.gate.outputs.should_release == 'true' }}
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

  # ========== CREATE RELEASE ==========
  create-release:
    needs: [gate, prepare, build-daemon, build-desktop, build-android]
    if: always() && needs.gate.outputs.should_release == 'true' && needs.prepare.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.gate.outputs.head_sha }}

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: List artifacts
        run: find artifacts -type f | sort

      - name: Generate version matrix
        id: versions
        run: |
          # Extract all versions
          RELEASE_VERSION="${{ needs.prepare.outputs.version }}"
          CARGO_VERSION=$(grep -m1 '^version = ' Cargo.toml | sed 's/version = "\(.*\)"/\1/')
          CLIENT_VERSION=$(jq -r '.version' client/package.json)
          SIGNALING_VERSION=$(jq -r '.version' signaling/package.json)
          TAURI_VERSION=$(jq -r '.version' client/src-tauri/tauri.conf.json)
          PROTOCOL_VERSION=$(grep -o 'PROTOCOL_VERSION.*=.*[0-9]*' crates/protocol/src/messages.rs | grep -o '[0-9]*$')

          # Generate version table as multiline output
          {
            echo "version_info<<EOF"
            echo "## Version Information"
            echo ""
            echo "| Component | Version |"
            echo "|-----------|---------|"
            echo "| Release | ${RELEASE_VERSION} |"
            echo "| Workspace (Cargo.toml) | ${CARGO_VERSION} |"
            echo "| Client (package.json) | ${CLIENT_VERSION} |"
            echo "| Signaling (package.json) | ${SIGNALING_VERSION} |"
            echo "| Desktop (tauri.conf.json) | ${TAURI_VERSION} |"
            echo "| Protocol Version | ${PROTOCOL_VERSION} |"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Create and push tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "v${{ needs.prepare.outputs.version }}" -m "Release v${{ needs.prepare.outputs.version }}"
          git push origin "v${{ needs.prepare.outputs.version }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.prepare.outputs.version }}
          name: v${{ needs.prepare.outputs.version }}
          body: |
            ## Changes since ${{ needs.prepare.outputs.prev_tag }}

            ${{ needs.prepare.outputs.changelog }}

            ${{ steps.versions.outputs.version_info }}

            ## Downloads

            | Platform | Daemon | Desktop App |
            |----------|--------|-------------|
            | Linux x86_64 | `remoshell-daemon-linux-x86_64` | `.AppImage`, `.deb` |
            | Android | - | `.apk` |

            **Web Client:** https://moukrea.github.io/remoshell/

            ---
            *macOS, Windows, and iOS builds are temporarily disabled while we stabilize the CI/CD pipeline.*
          draft: false
          files: |
            artifacts/daemon-*/*
            artifacts/desktop-*/**/*
            artifacts/android-apk/remoshell-client-android.apk
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
